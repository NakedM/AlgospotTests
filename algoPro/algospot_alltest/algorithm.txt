/////O(n^lg3) 카라츠바의 빠른 정수 곱셈 알고리즘
void addTo(vector<int> &a, const vector<int>& b, int k) //a += b(10^k)
void subFrom(vector<int> &a, const vector<int>& b); //a -= b

vector<int> karatsuba(const vector<int>& a, const vector<int>&b){
	int an = a.size();, bn=b.size();

	if(an < bn) return karatsuba(b,a);

	if(an == 0 || bn== 0 ) return vector<int>();

	if(an <= 50) return multiply(a,b); 

	//a와 b를 밑에서 half 자리와 나머지로 분리한다.
	int half = an/2;
	vector<int> a0(a.begin(), a.begin() + half);
	vector<int> a1(a.begin() + half, a.end());
	vector<int> b0(b.begin(), b.begin() + min<int>(b.size(),half));
	vector<int> b1(b.begin() + min<int>(b.size(),half), b.end());

	vector<int> z2 = karatsuba(a1, b1);
	vector<int> z0 = karatsuba(a0, b0);
	addTo(a0, a1, 0);
	addTo(b0, b1, 0);

	vector<int> z1 = karatsuba(a0, b0);
	subFrom(z1, z0);
	subFrom(z1, z2);

	vector<int> ret;
	addTo(ret, z0, 0);
	addTo(ret, z1, half);
	addTo(ret, z2, half + half));
	return ret;
}

//////////////////////////에라토스테네스의 체를 이용한 빠른 소인수 분해

int minFactor[MAX_N};

void eratosthenes2(){
	minFactor[0] = minFactor[1] = -1;

	for(int i= 2; i<=n; ++i)
		minFactor[i] = i;

	int sqrtn = int(sqrt(n));
	for(int i = 2; i<= sqrtn; ++i){
		if(minFactor[i] == i){
			for(int j = i*i; j<=n j+=i)
				if(minFactor[j] == j)
					minFactor[j] = i;
		}
	}
}

vector<int> factor(int n) {
	vector<int> ret;

	while(n > 1){
		ret.push_back(minFactor[n]);
		n /= minFactor[n];
	}
	return ret;
}

////////////////////// 유클리드 알고리즘 (최대공약수)

int gcd(int p, int q){
	return q ==0 ? p : gcd(q, p % q);
}

<<<<<<< HEAD

////////////////////// a / b 보다 큰 최소 정수

int ceil(int a, int b){
	return (a + b - 1) / b;
}

<<<<<<< HEAD
=======
>>>>>>> origin/master
////////////////KMP 알고리즘
vector<int> getPartialMatch(const string& pat){
	int m = pat.size();
	vector<int> failf(m, 0);

	int begin = 1, matched = 0;

	while(begin + matched <m){
		if(pat[begin + matched] == pat[matched]){
			++matched;
			failf[begin + matched -1] = matched;
		}
		else {
			if(matched == 0)
				++begin;
			else {
				begin += matched - failf[matched - 1];
				matched = failf[matched - 1];
			}
		}
	}
	return failf;
}



vector<int> kmpSearch(const string& txt, const string& pat){
	int n = txt.size(), m = pat.size();
	vector<int> ret;
	
	vector<int> failf = getPartialMatch(pat);

	int begin = 0, matched = 0;
	while(begin <= n- m) {
		if(matched < m && txt[begin + matched] == pat[matched]){
			++matched;
			
			if(matched == m) 
				ret.push_back(begin);
		}
		else{
			if(matched == 0)
				++begin;
			else{
				begin += matched - failf[matched-1];
				
				matched = failf[matched -1];
			}
		}
	}	
	return ret;
}



<<<<<<< HEAD
///////////////
=======
///////////////
>>>>>>> origin/master
=======
>>>>>>> parent of 101dd87... Merge remote-tracking branch 'origin/master'
