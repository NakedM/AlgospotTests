/////O(n^lg3) 카라츠바의 빠른 정수 곱셈 알고리즘
void addTo(vector<int> &a, const vector<int>& b, int k) //a += b(10^k)
void subFrom(vector<int> &a, const vector<int>& b); //a -= b

vector<int> karatsuba(const vector<int>& a, const vector<int>&b){
	int an = a.size();, bn=b.size();

	if(an < bn) return karatsuba(b,a);

	if(an == 0 || bn== 0 ) return vector<int>();

	if(an <= 50) return multiply(a,b); 

	//a와 b를 밑에서 half 자리와 나머지로 분리한다.
	int half = an/2;
	vector<int> a0(a.begin(), a.begin() + half);
	vector<int> a1(a.begin() + half, a.end());
	vector<int> b0(b.begin(), b.begin() + min<int>(b.size(),half));
	vector<int> b1(b.begin() + min<int>(b.size(),half), b.end());

	vector<int> z2 = karatsuba(a1, b1);
	vector<int> z0 = karatsuba(a0, b0);
	addTo(a0, a1, 0);
	addTo(b0, b1, 0);

	vector<int> z1 = karatsuba(a0, b0);
	subFrom(z1, z0);
	subFrom(z1, z2);

	vector<int> ret;
	addTo(ret, z0, 0);
	addTo(ret, z1, half);
	addTo(ret, z2, half + half));
	return ret;
}

//////////////////////////에라토스테네스의 체를 이용한 빠른 소인수 분해

int minFactor[MAX_N};

void eratosthenes2(){
	minFactor[0] = minFactor[1] = -1;

	for(int i= 2; i<=n; ++i)
		minFactor[i] = i;

	int sqrtn = int(sqrt(n));
	for(int i = 2; i<= sqrtn; ++i){
		if(minFactor[i] == i){
			for(int j = i*i; j<=n j+=i)
				if(minFactor[j] == j)
					minFactor[j] = i;
		}
	}
}

vector<int> factor(int n) {
	vector<int> ret;

	while(n > 1){
		ret.push_back(minFactor[n]);
		n /= minFactor[n];
	}
	return ret;
}

////////////////////// 유클리드 알고리즘 (최대공약수)

int gcd(int p, int q){
	return q ==0 ? p : gcd(q, p % q);
}

<<<<<<< HEAD

////////////////////// a / b 보다 큰 최소 정수

int ceil(int a, int b){
	return (a + b - 1) / b;
}

<<<<<<< HEAD
=======
>>>>>>> origin/master
////////////////KMP 알고리즘
vector<int> getPartialMatch(const string& pat){
	int m = pat.size();
	vector<int> failf(m, 0);

	int begin = 1, matched = 0;

	while(begin + matched <m){
		if(pat[begin + matched] == pat[matched]){
			++matched;
			failf[begin + matched -1] = matched;
		}
		else {
			if(matched == 0)
				++begin;
			else {
				begin += matched - failf[matched - 1];
				matched = failf[matched - 1];
			}
		}
	}
	return failf;
}



vector<int> kmpSearch(const string& txt, const string& pat){
	int n = txt.size(), m = pat.size();
	vector<int> ret;
	
	vector<int> failf = getPartialMatch(pat);

	int begin = 0, matched = 0;
	while(begin <= n- m) {
		if(matched < m && txt[begin + matched] == pat[matched]){
			++matched;
			
			if(matched == m) 
				ret.push_back(begin);
		}
		else{
			if(matched == 0)
				++begin;
			else{
				begin += matched - failf[matched-1];
				
				matched = failf[matched -1];
			}
		}
	}	
	return ret;
}



/////////////////접미사 배열을 계산하는 맨버와 마이어스의 알고리즘
struct Comparator {
	const vector<int>& group;
	int t;
	Comparator(const vector<int>& _group, int _t) : group(_group), t(_t) {}

	bool operator () (int a, int b){
		if (group[a] != group[b]) return group[a] < group[b];

		return group[a + t] < group[b + t];
	}
};

vector<int> getSuffixArray(const string& s){
	int n = s.size();

	int t = 1;
	vector<int> group(n + 1);
	for (int i = 0; i < n; ++i)
		group[i] = s[i];

	group[n] = -1;

	vector<int> perm(n);
	for (int i = 0; i < n; i++)
		perm[i] = i;

	while (t < n){

		Comparator compareUsing2T(group, t);
		sort(perm.begin(), perm.end(), compareUsing2T);
		for (int i = 0; i < group.size(); i++)
			cout << group[i] << " ";
		cout << endl;

		t *= 2;
		if (t >= n) break;

		vector<int> newGroup(n + 1);
		newGroup[n] = -1;
		newGroup[perm[0]] = 0;
		for (int i = 1; i < n; i++){
			if (compareUsing2T(perm[i - 1], perm[i]))
				newGroup[perm[i]] = newGroup[perm[i - 1]] + 1;
			else
				newGroup[perm[i]] = newGroup[perm[i - 1]];
		}
		group = newGroup;
	}
	return perm;
}